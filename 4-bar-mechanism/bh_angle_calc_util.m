function varargout = bh_angle_calc_util(L_1, L_2, L_3, L_4, theta, action_str)
% ALLOWED USAGE:
%  >> some_angle           = bh_angle_calc_util(L_1, L_2, L_3, L_4, theta, "CALC_PHI_FOR_POS_PHI")
%  >> [phi_col, alpha_col] = bh_angle_calc_util(L_1, L_2, L_3, L_4, theta, "CALC_PHI_AND_ALPHA_VEC")
%  >> [phi_val, alpha_val] = bh_angle_calc_util(L_1, L_2, L_3, L_4, theta, "CALC_PHI_AND_ALPHA_VAL_AND_PHI_IS_POS")
%--------------------------------------------------------------------------

%    phi_sol_1     = bh_phi_1_func(L_1, L_2, L_3, L_4, theta);
%    phi_sol_2     = bh_phi_2_func(L_1, L_2, L_3, L_4, theta);
      
   [the_z, the_num, the_den] = bh_z_calc_util(L_1, L_2, L_3, L_4, theta, "CALC_Z");
   
   phi_sol_1 = 2*atan2( the_num(1), the_den(1)  );
   phi_sol_2 = 2*atan2( the_num(2), the_den(2)  );
      
   % since the computations for PHI involve:  2*atan2(...) then the 
   % angular range for PHI is 2*[-pi, pi].  So let's bring this back to
   % the range [-pi, pi].
   
   assert(length(phi_sol_1)==length(phi_sol_2))
   
   for kk=1:length(phi_sol_1)
      if( isreal(phi_sol_1(kk))) 
         x1            = cos(phi_sol_1(kk));
         y1            = sin(phi_sol_1(kk));
         phi_sol_1(kk) = atan2(y1,x1);
      end
   
       if( isreal(phi_sol_2(kk))) 
         x2            = cos(phi_sol_2(kk));
         y2            = sin(phi_sol_2(kk));
         phi_sol_2(kk) = atan2(y2,x2);
      end
   end
   
   alpha_sol_1   = bh_alpha_func(L_1, L_2, L_3, L_4, theta, phi_sol_1);
   alpha_sol_2   = bh_alpha_func(L_1, L_2, L_3, L_4, theta, phi_sol_2);
      
   switch(upper(action_str))
       case "CALC_PHI_AND_ALPHA_VEC"
            varargout{1} = [  phi_sol_1;   phi_sol_2];  % phi
            varargout{2} = [alpha_sol_1; alpha_sol_2];  % alpha
       case "CALC_PHI_FOR_POS_PHI"
            phi = LOC_CALC_PHI_FOR_POS_PHI(phi_sol_1, phi_sol_2, alpha_sol_1, alpha_sol_2);
            varargout{1} = phi;
       case "CALC_PHI_FOR_POS_ALPHA"
            phi = LOC_CALC_PHI_FOR_POS_ALPHA(phi_sol_1, phi_sol_2, alpha_sol_1, alpha_sol_2);
            varargout{1} = phi;
       case "CALC_PHI_AND_ALPHA_VAL_AND_PHI_IS_POS"
           [the_phi, the_alpha] = LOC_CALC_PHI_AND_ALPHA_VAL_AND_PHI_IS_POS(phi_sol_1, phi_sol_2, alpha_sol_1, alpha_sol_2);
           varargout{1} = the_phi;
           varargout{2} = the_alpha;
       otherwise
          error("ERROR:  unknown action string !");     
   end
end
%_#########################################################################

%--------------------------------------------------------------------------
function THE_PHI = LOC_CALC_PHI_FOR_POS_ALPHA(phi_sol_1, phi_sol_2, alpha_sol_1, alpha_sol_2)
  if(alpha_sol_1 >= 0 )
      THE_PHI = phi_sol_1;
  else
     THE_PHI = phi_sol_2; 
  end
end
%--------------------------------------------------------------------------
function THE_PHI = LOC_CALC_PHI_FOR_POS_PHI(phi_sol_1, phi_sol_2, alpha_sol_1, alpha_sol_2)
  if(phi_sol_1 >= 0 )
      THE_PHI = phi_sol_1;
  else
     THE_PHI = phi_sol_2; 
  end
end
%--------------------------------------------------------------------------
function [THE_PHI, THE_ALPHA] = LOC_CALC_PHI_AND_ALPHA_VAL_AND_PHI_IS_POS(phi_sol_1, phi_sol_2, alpha_sol_1, alpha_sol_2)
  if(phi_sol_1 >= 0 )
      THE_PHI   =   phi_sol_1;
      THE_ALPHA = alpha_sol_1;
  else
      THE_PHI   =   phi_sol_2; 
      THE_ALPHA = alpha_sol_2;
  end
  
%   if(phi_sol_2 >= 0 )
%       THE_PHI   =   phi_sol_2;
%       THE_ALPHA = alpha_sol_2;
%   else
%       THE_PHI   =   phi_sol_1; 
%       THE_ALPHA = alpha_sol_1;
%   end
end
%_#########################################################################
function phi_sol_1 = bh_phi_1_func(L_1,L_2,L_3,L_4,theta)
%BH_PHI_1_FUNC
%    PHI_SOL_1 = BH_PHI_1_FUNC(L_1,L_2,L_3,L_4,THETA)

%    This function was generated by the Symbolic Math Toolbox version 8.3.
%    02-Jul-2019 08:53:05

t2 = cos(theta);
t3 = L_1.^2;
t4 = L_2.^2;
t5 = L_3.^2;
t6 = L_4.^2;
t7 = L_2.*L_3.*2.0;
t8 = -t4;
t9 = L_1.*L_4.*t2.*2.0;
t10 = -t9;
phi_sol_1 = atan2(sqrt((t3-t5+t6+t7+t8+t10).*(-t3+t4+t5-t6+t7+t9))+L_1.*L_3.*sin(theta).*2.0,t3+t5+t6+t8+t10-L_3.*L_4.*2.0+L_1.*L_3.*t2.*2.0).*2.0;
end
%--------------------------------------------------------------------------
function phi_sol_2 = bh_phi_2_func(L_1,L_2,L_3,L_4,theta)
%BH_PHI_2_FUNC
%    PHI_SOL_2 = BH_PHI_2_FUNC(L_1,L_2,L_3,L_4,THETA)

%    This function was generated by the Symbolic Math Toolbox version 8.3.
%    02-Jul-2019 08:53:05

t2 = cos(theta);
t3 = L_1.^2;
t4 = L_2.^2;
t5 = L_3.^2;
t6 = L_4.^2;
t7 = L_2.*L_3.*2.0;
t8 = -t4;
t9 = L_1.*L_4.*t2.*2.0;
t10 = -t9;
phi_sol_2 = atan2(-sqrt((t3-t5+t6+t7+t8+t10).*(-t3+t4+t5-t6+t7+t9))+L_1.*L_3.*sin(theta).*2.0,t3+t5+t6+t8+t10-L_3.*L_4.*2.0+L_1.*L_3.*t2.*2.0).*2.0;
end
%--------------------------------------------------------------------------
function alpha_sol = bh_alpha_func(L_1,L_2,L_3,L_4,theta,phi)
%BH_ALPHA_FUNC
%    ALPHA_SOL = BH_ALPHA_FUNC(L_1,L_2,L_3,L_4,THETA,PHI)

%    This function was generated by the Symbolic Math Toolbox version 8.3.
%    02-Jul-2019 08:53:05

alpha_sol = atan2(L_3.*sin(phi)-L_1.*sin(theta),L_4+L_3.*cos(phi)-L_1.*cos(theta));
end
%--------------------------------------------------------------------------
